#include <include/kernel/isr/isr_index.h>
#include <include/kernel/kapi.h>

bool critical_exceptions[] = 
{
    DIVIDE_ERROR,
    OVERFLOW,
    BOUND_RANGE_EXCEEDED,
    INVALID_OPCODE,
    DOUBLE_FAULT,
    INVALID_TSS,
    SEGMENT_NOT_PRESENT,
    STACK_SEGMENT_FAULT,
    GENERAL_PROTECTION_FAULT,
    PAGE_FAULT,
    MATH_FAULT,
    ALIGNMENT_CHECK,
    SIMD_FLOATING_POINT_EXCEPTION,
    CONTROL_PROTECTION_EXCEPTION
};

bool has_error_code[NUM_RESERVED_VECTORS] = 
{
    [DOUBLE_FAULT] = true,   
    [INVALID_TSS] = true,  
    [SEGMENT_NOT_PRESENT] = true, 
    [STACK_SEGMENT_FAULT] = true,  
    [GENERAL_PROTECTION_FAULT] = true,  
    [PAGE_FAULT] = true,  
    [ALIGNMENT_CHECK] = true,  
    [CONTROL_PROTECTION_EXCEPTION] = true,  
};

interrupt_type_t interrupt_type_arr[NUM_RESERVED_VECTORS] =
{
    [DIVIDE_ERROR] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [DEBUG_EXCEPTION] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [NMI] = INTERRUPT_TYPE_NMI,
    [BREAKPOINT] = INTERRUPT_TYPE_SOFTWARE_EXCEPTION,
    [OVERFLOW] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [BOUND_RANGE_EXCEEDED] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [INVALID_OPCODE] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [DEVICE_NOT_AVAILABLE] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [DOUBLE_FAULT] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [COPROCESSOR_SEGMENT_OVERRUN] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [INVALID_TSS] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [SEGMENT_NOT_PRESENT] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [STACK_SEGMENT_FAULT] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [GENERAL_PROTECTION_FAULT] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [PAGE_FAULT] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [VECTOR15] = INTERRUPT_TYPE_EXTERNAL,
    [MATH_FAULT] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [ALIGNMENT_CHECK] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [MACHINE_CHECK] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [SIMD_FLOATING_POINT_EXCEPTION] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [VIRTUALISATION_EXCEPTION] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [CONTROL_PROTECTION_EXCEPTION] = INTERRUPT_TYPE_HARDWARE_EXCEPTION,
    [VECTOR22] = INTERRUPT_TYPE_EXTERNAL,
    [VECTOR23] = INTERRUPT_TYPE_EXTERNAL,
    [VECTOR24] = INTERRUPT_TYPE_EXTERNAL,
    [VECTOR25] = INTERRUPT_TYPE_EXTERNAL,
    [VECTOR26] = INTERRUPT_TYPE_EXTERNAL,
    [VECTOR27] = INTERRUPT_TYPE_EXTERNAL,
    [VECTOR28] = INTERRUPT_TYPE_EXTERNAL,
    [VECTOR29] = INTERRUPT_TYPE_EXTERNAL,
    [VECTOR30] = INTERRUPT_TYPE_EXTERNAL,
    [VECTOR31] = INTERRUPT_TYPE_EXTERNAL
};

char *vector_to_str[NUM_RESERVED_VECTORS] = 
{
    [DIVIDE_ERROR] = "DIVIDE_ERROR",
    [DEBUG_EXCEPTION] = "DEBUG_EXCEPTION",
    [NMI] = "NMI",
    [BREAKPOINT] = "BREAKPOINT",
    [OVERFLOW] ="OVERFLOW",
    [BOUND_RANGE_EXCEEDED] = "BOUND_RANGE_EXCEEDED", 
    [INVALID_OPCODE] = "INVALID_OPCODE",
    [DEVICE_NOT_AVAILABLE] = "DEVICE_NOT_AVAILABLE",
    [DOUBLE_FAULT] = "DOUBLE_FAULT",
    [COPROCESSOR_SEGMENT_OVERRUN] = "COPROCESSOR_SEGMENT_OVERRUN",
    [INVALID_TSS] = "INVALID_TSS",
    [SEGMENT_NOT_PRESENT] = "SEGMENT_NOT_PRESENT",
    [STACK_SEGMENT_FAULT] = "STACK_SEGMENT_FAULT",
    [GENERAL_PROTECTION_FAULT] = "GENERAL_PROTECTION_FAULT",
    [PAGE_FAULT] = "PAGE_FAULT",
    [VECTOR15] = "VECTOR15",
    [MATH_FAULT] = "MATH_FAULT",
    [ALIGNMENT_CHECK] = "ALIGNMENT_CHECK",
    [MACHINE_CHECK] = "MACHINE_CHECK",
    [SIMD_FLOATING_POINT_EXCEPTION] = "SIMD_FLOATING_POINT_EXCEPTION",
    [VIRTUALISATION_EXCEPTION] = "VIRTUALISATION_EXCEPTION",
    [CONTROL_PROTECTION_EXCEPTION] = "CONTROL_PROTECTION_EXCEPTION",
    [VECTOR22] = "VECTOR22",
    [VECTOR23] = "VECTOR23",
    [VECTOR24] = "VECTOR24",
    [VECTOR25] = "VECTOR25",
    [VECTOR26] = "VECTOR26",
    [VECTOR27] = "VECTOR27",
    [VECTOR28] = "VECTOR28",
    [VECTOR29] = "VECTOR29",
    [VECTOR30] = "VECTOR30",
    [VECTOR31] = "VECTOR31"
};

u64 get_int_stack(struct interrupt_info *ctx)
{
    u8 vector = ctx->vector;
    if (vector == NMI || vector == DOUBLE_FAULT || vector == MACHINE_CHECK)
        return (u64)ctx;

    struct per_cpu *this_cpu = this_cpu_data();
    u8 priority = vector_to_intl(vector);

    char *stack = this_cpu->int_stacks[priority];
    u64 top = (u64)&stack[sizeof(this_cpu->int_stacks[priority])];

    struct interrupt_info *rsp = (void *)(top - sizeof(struct interrupt_info));
    *rsp = *ctx;

    return (u64)rsp;
}